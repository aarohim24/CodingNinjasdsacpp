/*print level wise*/
/**********************************************************

	Following is the Binary Tree Node class structure

	template <typename T>
	class BinaryTreeNode {
    	public : 
    	T data;
    	BinaryTreeNode<T> *left;
    	BinaryTreeNode<T> *right;

    	BinaryTreeNode(T data) {
        	this -> data = data;
        	left = NULL;
        	right = NULL;
    	}
	};

***********************************************************/
void printLevelWise(BinaryTreeNode<int> *root) {
    if (root == NULL) {
        return;
    }

    queue<BinaryTreeNode<int>*> q;
    q.push(root);

    while (!q.empty()) {
        BinaryTreeNode<int>* node = q.front();
        q.pop();

        cout << node->data << ":L:";

        if (node->left != NULL) {
            cout << node->left->data;
            q.push(node->left);
        } else {
            cout << -1;
        }

        cout << ",R:";

        if (node->right != NULL) {
            cout << node->right->data;
            q.push(node->right);
        } else {
            cout << -1;
        }

        cout << endl;
    }
}




/************************************************************
is node present?

    Following is the Binary Tree node structure

    template <typename T>
    class BinaryTreeNode
    {
        public :
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T data)
        {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/
bool isNodePresent(BinaryTreeNode<int> *root, int x) {
    if (root == NULL) {
        return false;
    }

    if (root->data == x) {
        return true;
    }

    return isNodePresent(root->left, x) || isNodePresent(root->right, x);
}





/***********************************************************
HEIGHT OF BINARY TREE
	Following is the Binary Tree Node class structure

	template <typename T>
	class BinaryTreeNode {
    	public : 
    	T data;
    	BinaryTreeNode<T> *left;
    	BinaryTreeNode<T> *right;

    	BinaryTreeNode(T data) {
        	this -> data = data;
        	left = NULL;
        	right = NULL;
    	}
	};

***********************************************************/
int height(BinaryTreeNode<int>* root) {
    if (root == NULL) {
        return 0;
    }

    int leftHeight = height(root->left);
    int rightHeight = height(root->right);

    return max(leftHeight, rightHeight) + 1;
}





/**********************************************************
MIRROR
	Following is the Binary Tree Node class structure

	template <typename T>
	class BinaryTreeNode {
    	public : 
    	T data;
    	BinaryTreeNode<T> *left;
    	BinaryTreeNode<T> *right;

    	BinaryTreeNode(T data) {
        	this -> data = data;
        	left = NULL;
        	right = NULL;
    	}
	};

***********************************************************/
void mirrorBinaryTree(BinaryTreeNode<int>* root) {
    if (root == NULL) {
        return;
    }
    mirrorBinaryTree(root->left);
    mirrorBinaryTree(root->right);

    BinaryTreeNode<int>* temp = root->left;
    root->left = root->right;
    root->right = temp;
}

void printLevelWise(BinaryTreeNode<int> *root) {
    if (root == NULL) {
        return;
    }

    queue<BinaryTreeNode<int>*> q;
    q.push(root);

    while (!q.empty()) {
        int nodeCount = q.size();

        while (nodeCount > 0) {
            BinaryTreeNode<int>* front = q.front();
            q.pop();

            cout << front->data << " ";

            if (front->left != NULL) {
                q.push(front->left);
            }
            if (front->right != NULL) {
                q.push(front->right);
            }

            nodeCount--;
        }

        cout << endl;
    }
}




/************************************************************
PREORDER TRAVERSAL

    Following is the TreeNode class structure

    template <typename T>
    class TreeNode {
       public:
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/

void preOrderHelper(TreeNode<int>* node, vector<int> &result) {
    if (node == NULL) {
        return;
    }

    result.push_back(node->data);
    preOrderHelper(node->left, result);
    preOrderHelper(node->right, result);
}

vector<int> preOrder(TreeNode<int> *root) {
    vector<int> result;
    preOrderHelper(root, result);
    return result;
}


/**********************************************************
POSTORDER BINARY TREE
	Following is the Binary Tree Node class structure

	template <typename T>
	class BinaryTreeNode {
    	public : 
    	T data;
    	BinaryTreeNode<T> *left;
    	BinaryTreeNode<T> *right;

    	BinaryTreeNode(T data) {
        	this -> data = data;
        	left = NULL;
        	right = NULL;
    	}
	};

***********************************************************/

void postOrder(BinaryTreeNode<int> *root) {
    if (root == NULL) {
        return;
    }

    postOrder(root->left);
    postOrder(root->right);
    cout << root->data << " ";
}





/***********************************************************
CONSTRUCT TREE FROM PREORDER AND INORDER
	Following is the Binary Tree Node class structure

	template <typename T>
	class BinaryTreeNode {
    	public : 
    	T data;
    	BinaryTreeNode<T> *left;
    	BinaryTreeNode<T> *right;

    	BinaryTreeNode(T data) {
        	this -> data = data;
        	left = NULL;
        	right = NULL;
    	}
	};

***********************************************************/


BinaryTreeNode<int>* buildTree(int *preorder, int preLength, int *inorder, int inLength) {
  if (preLength == 0 || inLength == 0) {
    return nullptr;
  }

  int rootValue = preorder[0];

  int i = 0;
  while (inorder[i] != rootValue && i < inLength) {
    i++;
  }

  BinaryTreeNode<int> *root = new BinaryTreeNode<int>(rootValue);

  int leftSubtreeLength = i;
  int rightSubtreeLength = inLength - i - 1;

  root->left = buildTree(preorder + 1, leftSubtreeLength, inorder, leftSubtreeLength);
  root->right = buildTree(preorder + leftSubtreeLength + 1, rightSubtreeLength, inorder + leftSubtreeLength + 1, rightSubtreeLength);

  return root;
}


/***********************************************************
CONSTRUCT TREE FROM POSTORDER & INORDER
**********************************************************/
#include <iostream>
#include <unordered_map>

BinaryTreeNode<int>* buildTreeRecursive(int *postorder, int postStart, int postEnd, int *inorder, int inStart, int inEnd, std::unordered_map<int, int> &indexMap);

BinaryTreeNode<int>* buildTree(int *postorder, int postLength, int *inorder, int inLength) {
  std::unordered_map<int, int> indexMap;
  for (int i = 0; i < inLength; i++) {
    indexMap[inorder[i]] = i;
  }

  return buildTreeRecursive(postorder, 0, postLength - 1, inorder, 0, inLength - 1, indexMap);
}

BinaryTreeNode<int>* buildTreeRecursive(int *postorder, int postStart, int postEnd, int *inorder, int inStart, int inEnd, std::unordered_map<int, int> &indexMap) {
  if (postStart > postEnd || inStart > inEnd) {
    return NULL;
  }

  int rootValue = postorder[postEnd];
  int rootIndex = indexMap[rootValue];

  BinaryTreeNode<int> *root = new BinaryTreeNode<int>(rootValue);

  int leftSubtreeLength = rootIndex - inStart;
  int rightSubtreeLength = inEnd - rootIndex;

  root->left = buildTreeRecursive(postorder, postStart, postStart + leftSubtreeLength - 1, inorder, inStart, rootIndex - 1, indexMap);
  root->right = buildTreeRecursive(postorder, postStart + leftSubtreeLength, postEnd - 1, inorder, rootIndex + 1, inEnd, indexMap);


  return root;
}




/**************************************************
MIN AND MAX OF BINARY TREE
**************************************************/
#include <iostream>
#include <utility>
#include <climits>
using namespace std;


pair<int, int> getMinAndMax(BinaryTreeNode<int> *root) {
    if (root == NULL) {
        return {INT_MAX, INT_MIN};
    }

    pair<int, int> leftMinMax = getMinAndMax(root->left);
    pair<int, int> rightMinMax = getMinAndMax(root->right);

    int minVal = min(root->data, min(leftMinMax.first, rightMinMax.first));
    int maxVal = max(root->data, max(leftMinMax.second, rightMinMax.second));

    return {minVal, maxVal};
}




/**********************************************************
SUM OF NODES
	Following is the Binary Tree Node class structure

	template <typename T>
	class BinaryTreeNode {
    	public : 
    	T data;
    	BinaryTreeNode<T> *left;
    	BinaryTreeNode<T> *right;

    	BinaryTreeNode(T data) {
        	this -> data = data;
        	left = NULL;
        	right = NULL;
    	}
	};

***********************************************************/


int getSum(BinaryTreeNode<int>* root) {
    if (root == NULL) {
        return 0;
    }
    
    int leftSum = getSum(root->left);
    int rightSum = getSum(root->right);
    
    return root->data + leftSum + rightSum;
}




/**********************************************************
CHECK BALANCED
	Following is the Binary Tree Node class structure

	template <typename T>
	class BinaryTreeNode {
    	public : 
    	T data;
    	BinaryTreeNode<T> *left;
    	BinaryTreeNode<T> *right;

    	BinaryTreeNode(T data) {
        	this -> data = data;
        	left = NULL;
        	right = NULL;
    	}
	};

***********************************************************/

class BalancedStatusWithHeight {
public:
    bool balanced;
    int height;
    
    BalancedStatusWithHeight(bool balanced, int height) : balanced(balanced), height(height) {}
};

BalancedStatusWithHeight checkBalanced(BinaryTreeNode<int> *root) {
    if (root == nullptr) {
        return BalancedStatusWithHeight(true, 0);
    }

    BalancedStatusWithHeight leftResult = checkBalanced(root->left);
    if (!leftResult.balanced) {
        return BalancedStatusWithHeight(false, 0);
    }

    BalancedStatusWithHeight rightResult = checkBalanced(root->right);
    if (!rightResult.balanced) {
        return BalancedStatusWithHeight(false, 0);
    }

    bool isBalanced = abs(leftResult.height - rightResult.height) <= 1;
    int height = 1 + max(leftResult.height, rightResult.height);
    
    return BalancedStatusWithHeight(isBalanced, height);
}

bool isBalanced(BinaryTreeNode<int> *root) {
    return checkBalanced(root).balanced;
}






/**********************************************************
LEVEL ORDER TRAVERSAL

	Following is the Binary Tree Node class structure

	template <typename T>
	class BinaryTreeNode {
    	public : 
    	T data;
    	BinaryTreeNode<T> *left;
    	BinaryTreeNode<T> *right;

    	BinaryTreeNode(T data) {
        	this -> data = data;
        	left = NULL;
        	right = NULL;
    	}
	};

***********************************************************/
/*#include <iostream>
#include <queue>
using namespace std;

template <typename T>
class BinaryTreeNode {
    public: 
    T data;
    BinaryTreeNode<T> *left;
    BinaryTreeNode<T> *right;

    BinaryTreeNode(T data) {
        this->data = data;
        left = NULL;
        right = NULL;
    }
};
*/

void printLevelWise(BinaryTreeNode<int> *root) {
    if (root == NULL) {
        return;
    }

    queue<BinaryTreeNode<int>*> q;
    q.push(root);

    while (!q.empty()) {
        int levelSize = q.size();
        
        for (int i = 0; i < levelSize; i++) {
            BinaryTreeNode<int>* currentNode = q.front();
            q.pop();
            
            cout << currentNode->data;
            if (i < levelSize - 1) {
                cout << " ";
            }
            
            if (currentNode->left != NULL) {
                q.push(currentNode->left);
            }
            if (currentNode->right != NULL) {
                q.push(currentNode->right);
            }
        }
        
        cout << endl;
    }
}






/**********************************************************
REMOVE LEAF NODES
	Following is the Binary Tree Node class structure

	template <typename T>
	class BinaryTreeNode {
    	public : 
    	T data;
    	BinaryTreeNode<T> *left;
    	BinaryTreeNode<T> *right;

    	BinaryTreeNode(T data) {
        	this -> data = data;
        	left = NULL;
        	right = NULL;
    	}
	};

***********************************************************/
BinaryTreeNode<int>* removeLeafNodes(BinaryTreeNode<int> *root) {
    if (root == NULL) {
        return NULL;
    }

    if (root->left == NULL && root->right == NULL) {
        delete root;
        return NULL;
    }

    root->left = removeLeafNodes(root->left);
    root->right = removeLeafNodes(root->right);
    return root;
}

void printLevelWise(BinaryTreeNode<int> *root) {
    if (root == NULL) {
        return;
    }

    queue<BinaryTreeNode<int>*> q;
    q.push(root);

    while (!q.empty()) {
        int levelSize = q.size();
        
        for (int i = 0; i < levelSize; i++) {
            BinaryTreeNode<int>* currentNode = q.front();
            q.pop();
            
            cout << currentNode->data;
            if (i < levelSize - 1) {
                cout << " ";
            }
            
            if (currentNode->left != NULL) {
                q.push(currentNode->left);
            }
            if (currentNode->right != NULL) {
                q.push(currentNode->right);
            }
        }
        
        cout << endl;
    }
}




/**********************************************************
LEVEL WISE LINKED LIST

	Following are the Binary Tree Node class structure and
	the Node class structure

	template <typename T>
	class BinaryTreeNode {
    	public: 
    	T data;
    	BinaryTreeNode<T> *left;
    	BinaryTreeNode<T> *right;

    	BinaryTreeNode(T data) {
        	this->data = data;
        	left = NULL;
        	right = NULL;
    	}
	};

	template <typename T>
	class Node {
		public:
    	T data;
    	Node<T> *next;
    	Node(T data) {
        	this->data=data;
        	this->next=NULL;
    	}
	};

***********************************************************/


vector<Node<int>*> constructLinkedListForEachLevel(BinaryTreeNode<int> *root) {
    vector<Node<int>*> result;

    if (root == NULL) {
        return result;
    }

    queue<BinaryTreeNode<int>*> q;
    q.push(root);

    while (!q.empty()) {
        int levelSize = q.size();
        Node<int>* head = NULL;
        Node<int>* tail = NULL;

        for (int i = 0; i < levelSize; i++) {
            BinaryTreeNode<int>* currentNode = q.front();
            q.pop();

            Node<int>* newNode = new Node<int>(currentNode->data);
            if (head == NULL) {
                head = newNode;
                tail = newNode;
            } else {
                tail->next = newNode;
                tail = newNode;
            }

            if (currentNode->left != NULL) {
                q.push(currentNode->left);
            }
            if (currentNode->right != NULL) {
                q.push(currentNode->right);
            }
        }

        result.push_back(head);
    }

    return result;
}

void printLevelLinkedLists(const vector<Node<int>*>& lists) {
    for (Node<int>* head : lists) {
        Node<int>* current = head;
        while (current != NULL) {
            cout << current->data;
            if (current->next != NULL) {
                cout << " ";
            }
            current = current->next;
        }
        cout << endl;
    }
}





/**********************************************************
ZIGZAG TREE
	Following is the Binary Tree Node class structure

	template <typename T>
	class BinaryTreeNode {
    	public : 
    	T data;
    	BinaryTreeNode<T> *left;
    	BinaryTreeNode<T> *right;

    	BinaryTreeNode(T data) {
        	this -> data = data;
        	left = NULL;
        	right = NULL;
    	}
	};

***********************************************************/


#include <iostream>
#include <stack>
#include <vector>
using namespace std;

void zigZagOrder(BinaryTreeNode<int> *root) {
    if (root == NULL) {
        return;
    }

    stack<BinaryTreeNode<int>*> currentLevel;
    stack<BinaryTreeNode<int>*> nextLevel;
    currentLevel.push(root);
    bool leftToRight = true;

    while (!currentLevel.empty()) {
        BinaryTreeNode<int>* node = currentLevel.top();
        currentLevel.pop();

        if (node != NULL) {
            cout << node->data << " ";

            if (leftToRight) {
                if (node->left) {
                    nextLevel.push(node->left);
                }
                if (node->right) {
                    nextLevel.push(node->right);
                }
            } else {
                if (node->right) {
                    nextLevel.push(node->right);
                }
                if (node->left) {
                    nextLevel.push(node->left);
                }
            }
        }

        if (currentLevel.empty()) {
            cout << endl;
            leftToRight = !leftToRight;
            swap(currentLevel, nextLevel);
        }
    }
}





/**********************************************************
NODES WITHOUT SIBLING
	Following is the Binary Tree Node class structure

	template <typename T>
	class BinaryTreeNode {
    	public : 
    	T data;
    	BinaryTreeNode<T> *left;
    	BinaryTreeNode<T> *right;

    	BinaryTreeNode(T data) {
        	this -> data = data;
        	left = NULL;
        	right = NULL;
    	}
	};

***********************************************************/


#include <iostream>
#include <stack>
#include <vector>
using namespace std;

void zigZagOrder(BinaryTreeNode<int> *root) {
    if (root == NULL) {
        return;
    }

    stack<BinaryTreeNode<int>*> currentLevel;
    stack<BinaryTreeNode<int>*> nextLevel;
    currentLevel.push(root);
    bool leftToRight = true;

    while (!currentLevel.empty()) {
        BinaryTreeNode<int>* node = currentLevel.top();
        currentLevel.pop();

        if (node != NULL) {
            cout << node->data << " ";

            if (leftToRight) {
                if (node->left) {
                    nextLevel.push(node->left);
                }
                if (node->right) {
                    nextLevel.push(node->right);
                }
            } else {
                if (node->right) {
                    nextLevel.push(node->right);
                }
                if (node->left) {
                    nextLevel.push(node->left);
                }
            }
        }

        if (currentLevel.empty()) {
            cout << endl;
            leftToRight = !leftToRight;
            swap(currentLevel, nextLevel);
        }
    }
}





