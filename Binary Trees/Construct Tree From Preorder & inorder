Problem statement
For a given preorder and inorder traversal of a Binary Tree of type integer stored in an array/list, create the binary tree using the given two arrays/lists. You just need to construct the tree and return the root.

Note:
Assume that the Binary Tree contains only unique elements. 
Detailed explanation ( Input/output format, Notes, Images )
Constraints:
1 <= N <= 10^3
Where N is the total number of nodes in the binary tree.

Time Limit: 1 sec
Sample Input 1:
7
1 2 4 5 3 6 7 
4 2 5 1 6 3 7 
Sample Output 1:
1 
2 3 
4 5 6 7 
Sample Input 2:
6
5 6 2 3 9 10 
2 6 3 9 5 10 
Sample Output 2:
5 
6 10 
2 3 
9 

//code
/***********************************************************
	Following is the Binary Tree Node class structure

	template <typename T>
	class BinaryTreeNode {
    	public : 
    	T data;
    	BinaryTreeNode<T> *left;
    	BinaryTreeNode<T> *right;

    	BinaryTreeNode(T data) {
        	this -> data = data;
        	left = NULL;
        	right = NULL;
    	}
	};

***********************************************************/


BinaryTreeNode<int>* buildTree(int *preorder, int preLength, int *inorder, int inLength) {
  // Base case: Empty tree
  if (preLength == 0 || inLength == 0) {
    return nullptr;
  }

  // Get the root value from preorder traversal
  int rootValue = preorder[0];

  // Find the index of the root value in inorder traversal
  int i = 0;
  while (inorder[i] != rootValue && i < inLength) {
    i++;
  }

  // Create the root node
  BinaryTreeNode<int> *root = new BinaryTreeNode<int>(rootValue);

  // Calculate lengths of left and right subtrees
  int leftSubtreeLength = i;
  int rightSubtreeLength = inLength - i - 1;

  // Recursive calls to build left and right subtrees
  root->left = buildTree(preorder + 1, leftSubtreeLength, inorder, leftSubtreeLength);
  root->right = buildTree(preorder + leftSubtreeLength + 1, rightSubtreeLength, inorder + leftSubtreeLength + 1, rightSubtreeLength);

  // Return the constructed root node
  return root;
}


